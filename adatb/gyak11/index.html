<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
<title> Összefoglalás</title>
<meta name="color-scheme" content="light dark">
<link rel="stylesheet" href="../../assets/github-markdown.css">
<link rel="stylesheet" href="../../assets/article.css">

<link rel="stylesheet" href="xhttps://cdnjs.cloudflare.com/ajax/libs/prism/1.26.0/themes/prism-coy.min.css" integrity="sha512-LOT5F67SMZVdXMrvQe4S1ZHu5l6xk3CST2qqno9kY329OsJBBpybnq+fM9qG4ZSaNzPOjoGzHAeBamSSJyyuZg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.26.0/themes/prism-solarizedlight.min.css"  crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.26.0/plugins/line-numbers/prism-line-numbers.css"  crossorigin="anonymous" referrerpolicy="no-referrer" />
<style>
			body {
				box-sizing: border-box;
				min-width: 200px;
				max-width: 980px;
				margin: 0 auto;
				padding: 45px;
			}

			@media (prefers-color-scheme: dark) {
				body {
					background-color: #0d1117;
				}
			}
		</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css">
<style>
			.github-fork-ribbon:before {
				background-color: #121612;
			}
		</style>
</head>
<body>
<article class="markdown-body line-numbers">


<h1 id="osszefoglalas">Összefoglalás</h1>
<h2 id="a-select-utasitas-felepitese">A SELECT utasítás felépítése</h2>
<p>Az SQL lekérdező utasítása, alapformája a következő:</p>
<pre><code class="language-sql">SELECT*…       -- oszlopok kiválasztása
FROM …         -- táblák kiválasztása
WHERE …        -- szűrőfeltétel megadása a sorokra
GROUP BY …     -- csoportosítás
HAVING …       -- szűrőfeltétel a csoportokra
ORDER BY…      -- sorbarendezés
</code></pre>
<p><strong>Kiegészítés:</strong>  Az eredménysorok számát a TOP (n) [PERCENT] záradék megadásával befolyásolhatjuk:
pl:</p>
<pre><code class="language-sql">SELECT TOP 5 * FROM Szoba 
</code></pre>
<p>az első 5 szoba adatait jeleníti meg</p>
<h2 id="kifejezesek">Kifejezések</h2>
<p>Az egyszerű kifejezések konstansokat, változókat, oszlopneveket és függvényeket tartalmazhatnak, pl:</p>
<ul>
<li>'Dr.'              (szöveges konstans)</li>
<li>Nettóbér           (oszlopnév)</li>
<li>YEAR('2010.01.011') (függvény, dátum konstans)</li>
</ul>
<p>Az összetett kifejezések operátorokat is tartalmazhatnak, pl:</p>
<ul>
<li>'Dr.' + Vezetéknév + Keresztnév (összefűzés)</li>
<li>Nettóbér * 1.27                    (szorzás)</li>
</ul>
<p>A kifejezések mindig egy értéket adnak vissza</p>
<h3 id="case">CASE</h3>
<p>Többirányú elágazás megvalósítása, két formája van:</p>
<pre><code class="language-sql">CASE 
     WHEN feltétel1 THEN kifjezés1
     WHEN feltétel2 THEN kifejezés2
     …
	WHEN feltételn THEN kifejezésn
      [ELSE kifejezés]
END
</code></pre>
<pre><code class="language-sql">CASE kifejezés
     WHEN érték1 THEN kifjezés1
     WHEN érték2 THEN kifejezés2
     …
	WHEN értékn THEN kifejezésn
      [ELSE kifejezés]
END
</code></pre>
<h3 id="konstansok-es-tipusok">Konstansok és típusok</h3>
<table>
<thead>
<tr>
<th>Konstans</th>
<th>Típus</th>
<th>Példa</th>
</tr>
</thead>
<tbody>
<tr>
<td>Szöveges   konstans</td>
<td>varchar(x)   (x:   a szöveg max.   hossza)</td>
<td>’Budapest’</td>
</tr>
<tr>
<td>Unicode   szöveges konstans</td>
<td>nvarchar(x)   (x:   a szöveg max.   hossza)</td>
<td>N’Budapest’</td>
</tr>
<tr>
<td>Egész   konstans</td>
<td>int</td>
<td>25</td>
</tr>
<tr>
<td>Bit   konstans</td>
<td>bit</td>
<td>1</td>
</tr>
<tr>
<td>Decimális   konstans</td>
<td>decimal(x,   y)   (x:   a számjegyek száma,    y: a tizedesjegyek száma)</td>
<td>12.45</td>
</tr>
<tr>
<td>Dátum/Idő   konstans</td>
<td>date,      datetime,      time</td>
<td>’2012.01.15’   ’2020.02.11   22:11:33’   ’06:12:10’</td>
</tr>
</tbody>
</table>
<h3 id="fontosabb-fuggvenyek-operatorok">Fontosabb függvények, operátorok</h3>
<h4 id="fuggvenyek">Függvények</h4>
<table>
<thead>
<tr>
<th>Függvénytípus</th>
<th>Függvény</th>
</tr>
</thead>
<tbody>
<tr>
<td>DÁTUM/IDŐ</td>
<td>GETDATE(),   DAY(d), MONTH(d), YEAR(d),       DATEADD(x, y, z), DATEDIFF(x, y, z)</td>
</tr>
<tr>
<td>KONVERZIÓS</td>
<td>CAST(x   AS y), CONVERT(x, y)</td>
</tr>
<tr>
<td>MATEMATIKAI</td>
<td>POWER(x,   y), SQRT(x), ROUND(x, y), ABS(x)</td>
</tr>
<tr>
<td>SZÖVEG</td>
<td>LEN(x),   LEFT(x, y), RIGHT(x, y), LOWER(x), UPPER(x), CHARINDEX(x, y)</td>
</tr>
<tr>
<td>EGYÉB</td>
<td>ISNULL(x,   y), IIF(x, y, z)</td>
</tr>
</tbody>
</table>
<h4 id="operatorok">Operátorok</h4>
<table>
<thead>
<tr>
<th>Operátor típus</th>
<th>Operátor</th>
<th>Megjegyzés</th>
</tr>
</thead>
<tbody>
<tr>
<td>Aritmetikai   operátorok</td>
<td>+,   -, *, /, %</td>
<td>%:   az egész osztás maradéka</td>
</tr>
<tr>
<td>Logikai   operátorok</td>
<td>NOT,   AND, OR</td>
<td></td>
</tr>
<tr>
<td>Összehasonlító   operátorok</td>
<td>&lt;,   &gt;, =, &lt;&gt;, &gt;=, &lt;=</td>
<td></td>
</tr>
<tr>
<td>Szöveg   operátorok</td>
<td>+,   %, _</td>
<td>+:   szövegek összefűzése   %:   helyettesítő operátor (egy vagy több karakter vagy üres)   _:   helyettesítő operátor (egy karakter)</td>
</tr>
</tbody>
</table>
<h2 id="osszesites-aggregalas">Összesítés (aggregálás)</h2>
<ul>
<li>Az összesítő függvények értékek egy halmazán végeznek számítást, és egyetlen értéket adnak vissza.</li>
<li>Alapesetben a halmaz a tábla összes sorát jelenti</li>
<li>A számítás egy kifejezés kiértékelését jelenti</li>
<li>Az összesítő függvények (kivéve: COUNT(*)) nem veszik figyelembe a NULL értékeket</li>
</ul>
<p>Fontosabb összesítő függvények és szerepük:</p>
<ul>
<li>SUM(): egy adott kifejezés értékeit összegét adja vissza</li>
<li>AVG(): egy adott kifejezés értékeinek átlagát adja vissza</li>
<li>MIN() és MAX(): egy adott kifejezés értékei közül a legkisebbet, illetve legnagyobbat adja vissza</li>
<li>COUNT(): egy adott halmaz elemeinek számát adja vissza</li>
</ul>
<h2 id="csoportositas">Csoportosítás</h2>
<pre><code class="language-sql">SELECT…        -- oszlopok kiválasztása
FROM …         -- táblák kiválasztása
WHERE …        -- szűrőfeltétel megadása a sorokra
GROUP BY …     --  csoportosítás
HAVING …       -- szűrőfeltétel a csoportokra
ORDER BY…          -- sorbarendezés
</code></pre>
<p>A GROUP BY részben felsorolt mezők vagy kifejezések szerint csoportokat képezhetünk, és a SELECT részben alkalmazott számításokat ezekre a csoportokra alkalmazhatjuk. A HAVING részben a csoportokra adhatunk meg szűrőfeltételt.
Csoportosítás esetén a SELECT részben lévő oszlopoknak szerepelniük kell a GROUP BY felsorolásában, vagy egy összesítésben (mint az összesítő függvény paramétere)</p>
<h2 id="tablak-osszekapcsolasa-join-tipusok">Táblák összekapcsolása – JOIN típusok</h2>
<p><img src="1587964457825.png" alt="1587964457825.png" /></p>
<ul>
<li>(INNER) JOIN: Az A tábla idegen kulcsa megegyezik a B tábla kulcsával</li>
<li>LEFT (OUTER) JOIN: Az INNER JOIN eredményéhez hozzá veszi az A tábla minden további sorát is</li>
<li>RIGHT (OUTER) JOIN: Az INNER JOIN eredményéhez hozzá veszi az B tábla minden további sorát is</li>
<li>FULL (OUTER) JOINT: Az INNER JOIN eredményéhez hozzá veszi az A és B tábla minden további sorait is</li>
</ul>
<p>Az OUTER szó használata nem kötelező</p>
<h2 id="halmazmuveletek">Halmazműveletek</h2>
<h3 id="lekerdezesek-unioja-sql-ben">Lekérdezések uniója SQL-ben:</h3>
<pre><code class="language-sql">SELECT oszlopnevek
FROM ….
UNION (ALL)
SELECT oszlopnevek
FROM …
</code></pre>
<blockquote>
<p>UNION esetén az eredményhalmazban a duplikált (mindegyik lekérdezésben előforduló) sorok csak egyszer szerepelnek, UNION ALL esetén pedig annyiszor, ahányszor előfordulnak</p>
</blockquote>
<h3 id="lekerdezesek-metszete-sql-ben">Lekérdezések metszete SQL-ben:</h3>
<pre><code class="language-sql">SELECT oszlopnevek
FROM ……
INTERSECT
SELECT oszlopnevek
FROM …….
</code></pre>
<h3 id="lekerdezesek-kulonbsege-sql-ben">Lekérdezések különbsége SQL-ben:</h3>
<pre><code class="language-sql">SELECT oszlopnevek
FROM ……
EXCEPT
SELECT oszlopnevek
FROM ……
</code></pre>
<h2 id="adatdefinicios-parancsok">Adatdefiníciós parancsok</h2>
<h3 id="tabla-letrehozasa">Tábla létrehozása</h3>
<pre><code class="language-sql">CREATE TABLE táblanév* 
(
 oszlopnév1  típusnév1 [oszlopkényszerek1],
 oszlopnév2  típusnév2 [oszlopkényszerek2],

   …    oszlopnévn  típusnévn [oszlopkényszerekn]
    [, táblakényszerek]
)
</code></pre>
<blockquote>
<p>Ha a táblanév # karakterrel kezdődik, akkor un. Ideiglenes tábla jön létre. Ez csak az adott kapcsolat (munkamenet, session) időtartalma alatt létezik. Ha a táblanév ## karakterekkel kezdődik, akkor több egyidejű kapcsolat esetén az ideiglenes tábla mindegyikben elérhető lesz.</p>
</blockquote>
<h3 id="oszlop-hozzaadasa-modositasa-torlese">Oszlop hozzáadása, módosítása, törlése</h3>
<pre><code class="language-sql">ALTER TABLE táblanév 
ADD oszlopnév típus
</code></pre>
<pre><code class="language-sql">
ALTER TABLE táblanév
ALTER COLUMN 
oszlopnév típus
</code></pre>
<pre><code class="language-sql">ALTER TABLE táblanév
DROP COLUMN oszlopnév
</code></pre>
<h3 id="kenyszer-torlese">Kényszer törlése</h3>
<pre><code class="language-sql">ALTER TABLE táblanév
DROP CONSTRAINT kényszernév
</code></pre>
<h3 id="az-egesz-tabla-torlese">Az egész tábla törlése</h3>
<pre><code class="language-sql">DROP TABLE táblanév
</code></pre>
<blockquote>
<p>A tábla törlése a szerkezet meghagyásával</p>
</blockquote>
<pre><code class="language-sql">TRUNCATE TABLE táblanév
</code></pre>
<h2 id="kenyszerek">Kényszerek</h2>
<p>A kényszerek a lehetséges adatok halmazát leíró, korlátozó szabályok.
A kényszerek (a NULL/NOT NULL és a Default kivételével) megadhatók oszlop, illetve tábla szinten is (oszlopkényszerek, táblakényszerek)</p>
<ul>
<li>Not Null Constraint: kötelező-e kitölteni az adott oszlopot?</li>
<li>Check Constraint: teljesül-e az adott logikai feltétel?</li>
<li>Default Constraint: mi legyen az adott oszlop alapértelmezett értéke?</li>
<li>Unique Constraint: az adott oszlop vagy oszlopok értékei egyediek legyenek</li>
<li>Primary Key Constraint: az adott oszlop vagy több oszlop együtt elsődleges kulcs legyen</li>
<li>Foreign Key Constraint: az adott oszlop vagy több oszlop együtt idegen kulcs legyen</li>
</ul>
<h2 id="adatmanipulacios-parancsok">Adatmanipulációs parancsok</h2>
<h3 id="uj-sor-beszurasa">Új sor beszúrása</h3>
<pre><code class="language-sql">INSERT INTO táblanév 
(
   oszlopnév lista
)
VALUES
(
  értéklista
)
</code></pre>
<blockquote>
<p>Ha egy SELECT eredménysorait egy új táblába szeretnénk menteni, akkor használhatjuk a
SELECT oszlopnév lista INTO táblanév FROM … parancsot is.</p>
</blockquote>
<h3 id="sorok-torlese">Sorok törlése</h3>
<pre><code class="language-sql">DELETE FROM táblanév 
WHERE feltétel
</code></pre>
<h3 id="ertekek-modositasa">Értékek módosítása</h3>
<pre><code class="language-sql">UPDATE táblanév 
SET   oszlop1 = érték1,
        oszlop2 = érték2,
        ….
WHERE feltétel
</code></pre>
<h2 id="beagyazott-lekerdezesek">Beágyazott lekérdezések</h2>
<pre><code class="language-sql">SELECT select_list  
FROM table  
WHERE expr operator  
(SELECT select_list FROM table)
</code></pre>
<pre><code class="language-sql">SELECT ProductID, Name, ListPrice  
FROM production.Product  
WHERE ListPrice &gt; (SELECT AVG(ListPrice)  FROM Production.Product) --subquery 
</code></pre>
<p>Tipikus használat</p>
<ul>
<li>Ha szeretnénk összehasonlítani egy kifejezés értékét a beágyazott lekérdezés eredményével (legtöbbször &lt;, &gt;, = )</li>
<li>Ha szeretnénk eldönteni, hogy egy kifejezés eredménye benne van-e a beágyazott lekérdezés eredményhalmazában (IN)-</li>
<li>Ha szeretnénk eldönteni, hogy a beágyazott lekérdezés eredményhalmaza üres-e (EXISTS)</li>
</ul>
<h2 id="reszosszegek">Részösszegek</h2>
<p>Az oszlopneveket és a NULL értéket kombinálva csoportosít, és  megjeleníti a  részösszegeket valamint végösszeget. ROLLUP esetén a nem NULL oszlopok száma jobbról balra csökken, CUBE esetén a csoportosítás minden lehetséges kombinációt tartalmaz</p>
<pre><code class="language-sql">SELECT oszlopkifejezések*, 
             aggregálás
FROM …
GROUP BY ROLLUP(oszlopkifejezések*)
</code></pre>
<pre><code class="language-sql">SELECT oszlopkifejezések, 
             aggregálás
FROM …
GROUP BY CUBE(oszlopkifejezések)
</code></pre>
<h2 id="grouping-sets">GROUPING SETS</h2>
<p>A GROUP BY parancs kiegészítve a GROUPING SETS taggal lehetővé teszi, hogy többféle csoportosítást is megadjunk.
A csoportosításokat leíró oszlopkifejezéseket egymás után, zárójelek között , vesszővel elválasztva kell megadni.</p>
<p>Pl:</p>
<pre><code class="language-sql">SELECT oszlop1, oszlop2, SUM(oszlop3)
FROM table
GROUP BY GROUPING SETS(( oszlop1, oszlop2), (oszlop1)
)
</code></pre>
<h2 id="ablakok-particiok-analitikus-fuggvenyek">Ablakok, partíciók, analitikus függvények</h2>
<p>Formája:</p>
<pre><code class="language-sql">Függvény()*
OVER(
[PARTITION BY kifejezés] 
[ORDER BY kifejezés]
[ROWS | RANGE BETWEEN kezdőpont AND végpont])
</code></pre>
<p>A függvény lehet</p>
<ul>
<li>Aggregáló függvény (SUM, AVG, MIN, MAX, COUNT)</li>
<li>Analitikus függvény (LAG, LEAD, FIRST_VALUE, LAST_VALUE)</li>
<li>Ranking függvény (RANK, DENS_RANK, NTILE, ROW_NUMBER)</li>
</ul>
<h2 id="nezetek-tarolt-eljarasok-fuggvenyek">Nézetek, tárolt eljárások, függvények</h2>
<pre><code class="language-sql">CREATE VIEW view_név
[(oszlopnevek listája)] [WITH view_attribútumok]
AS SELECT_utasítás
[WITH CHECK OPTION]*
</code></pre>
<pre><code class="language-sql">CREATE PROCEDURE eljárás_név
[paraméterek listája][WITH eljárás_opciók]
AS 
[BEGIN]
Utasítások
[END]
</code></pre>
<pre><code class="language-sql">CREATE FUNCTION fv_név
([paraméterek listája])RETURNS adattípus_név
[WITH fv_opciók]
[AS]
BEGIN
Utasítások
RETURN skalár_kifejezés
END
</code></pre>
<pre><code class="language-sql">CREATE FUNCTION fv_név
([paraméterek listája])RETURNS TABLE
[WITH fv_opciók]
[AS] 
RETURN select_kifejezés
</code></pre>
<h1 id="hogyan-tovabb-az-sql-tudas-bovitese">Hogyan tovább? – Az SQL tudás bővítése</h1>
<ul>
<li>A tanult témakörök elmélyítése (pl: függvények esetén opcionális paraméterek kipróbálása és/vagy újabb függvények megismerése)</li>
<li>Ismerkedés újabb témákkal (pl: dinamikus SQL, triggerek, rekurzió stb.)</li>
<li>Más relációs adatbázis rendszerek megismerése(elsősorban Oracle, DB2, MySQL)</li>
<li>Tapasztalat szerzés a gyakorlatban (Junior szint: 1-3 év, Medior szint: 3-5 év, Senior szint: &gt;5 év)</li>
</ul>
<h1 id="feladatok">Feladatok</h1>
<p>A feladatok a szallashely adatbázishoz készültek,  létrehozásához szükséges script elérhető itt:
<a href="szallas.sql">szallas.sql</a></p>
<p><span class='tg_task'>▷</span>	Készítsen tárolt eljárást NEPTUNKÓD_SPFEROHELYEK néven, amely paraméterként kap egy egész számot, és listázza azon szobák adatait, ahol a férőhelyek száma (pótággyal együtt!) megegyezik a paraméter értékével!</p>
<ol type="a">
<li>Teszteljük a tárolt eljárás működését, pl: EXEC UJAENB_FEROHELYEK 4
<a href="gy11_01.mp4">Megoldás</a></li>
</ol>
<p><span class='tg_task'>▷</span>	Készítsen függvényt NEPTUNKÓD_UDFFoglalasszam néven, amely a paraméterként megadott ügyfél azonosítót felhasználva visszaadja, hogy az adott ügyfél eddig hányszor foglalt!</p>
<ol type="a">
<li>Teszteljük a fv. működését, pl: SELECT dbo.UJAENB_UDFFoglalasszam('kata')
<a href="gy11_02.mp4">Megoldás</a></li>
</ol>
<p><span class='tg_task'>▷</span>	Készítsen nézetet NEPTUNKÓD_VVendeghazSzobak néven, amely azon szobák adatait jeleníti meg, amelyek vendégházban vannak!</p>
<ol type="a">
<li>Egy új oszlopban jelenjen meg a szálláshely neve és zárójelben a helye is, pl: Gold Hotel (Budapest)!</li>
<li>Teszteljük a nézet működését, pl: SELECT * FROM UJAENB_VVendeghazSzobak
<a href="gy11_03.mp4">Megoldás</a></li>
</ol>
<p><span class='tg_task'>▷</span>	Készítsen nézetet NEPTUNKÓD_VHaviFoglalasszam néven, amely évenkénti, azon belül havi bontásban listázza a foglalások számát!</p>
<ol type="a">
<li>A foglalás dátumánál a METTOL oszlop értékét vegyük alapul!</li>
<li>Az oszlopokat nevezzük el értelemszerűen!</li>
<li>Teszteljük a nézet működését, pl: SELECT * FROM UJAENB_VHaviFoglalaszszam
<a href="gy11_04.mp4">Megoldás</a></li>
</ol>
<p><span class='tg_task'>▷</span>	Készítsen tárolt eljárást NEPTUNKÓD_SPPotagyasUGyfelek néven, amely azon vendégek adatait listázza, akik MINDIG pótágyas foglalást adtak le!</p>
<ol type="a">
<li>Az eredménylista ne tartalmazzon duplikált sorokat!</li>
<li>Teszteljük a tárolt eljárás működését, pl: EXEC UJAENB_SPPotagyasUgyfelek
<a href="gy11_05.mp4">Megoldás</a></li>
</ol>
<p><span class='tg_task'>▷</span>	<strong>Készítsen lekérdezést, amely listázza a foglalások azonosítóját, a foglalások időtartamát napokban, valamint a felnőttek és gyermekek számát!</strong></p>
<ol type="a">
<li>A listát szűrjük azokra az ügyfelekre, akik azonosítója 'a' vagy 'b' betűvel kezdődik!</li>
<li>Az oszlopokat nevezzük el értelemszerűen!</li>
</ol>
<p><span class='tg_task'>▷</span>	<strong>Készítsen lekérdezést, amely típusonként, azon belül csillagok száma szerinti bontásban megjeleníti a szálláshelyek számát!</strong></p>
<ol type="a">
<li>A listát szűrjük azokra a rekordokra, ahol a szálláshelyek száma 4-nél kisebb!</li>
<li>A listából hagyjuk ki a budapesti szálláshelyeket!</li>
</ol>
<p><span class='tg_task'>▷</span>	<strong>Listázzuk a foglalások adatait! A gyermekkel érkezők külön ajándékot kapnak.</strong></p>
<ol type="a">
<li>Ezért egy új oszlopban jelenítsük meg, hogy az adott foglaláshoz jár-e ajándék (Igen-Nem).</li>
<li>A listát szűrjük a 3 csillagos szállásokra!</li>
</ol>
<p><span class='tg_task'>▷</span>	<strong>Melyek azok a vendégek, akiknek már volt gyermekes és gyermek nélküli foglalásuk is?</strong></p>
<ol type="a">
<li>Csak az ügyfelek azonosítója és neve jelenjen meg!</li>
<li>Az oszlopok neve legyen 'Azonosító' és 'Ügyfél'</li>
<li>A listát rendezzük név szerint növekvő sorrendbe!</li>
</ol>
<p><span class='tg_task'>▷</span>	<strong>Melyek azok a szálláshelyek, ahol a legtöbb főre foglaltak?</strong></p>
<ol type="a">
<li>Csak a szálláshelyek azonosítója, neve és helye jelenjen meg!</li>
<li>A lista ne tartalmazzon ismétlődő sorokat!</li>
</ol>
<p><span class='tg_task'>▷</span>	<strong>Készítsünk lekérdezést, amely a szállás helye szerint, azon belül a foglalás éve szerint megjeleníti, hogy hány foglalás történt! (A foglalás időpontjánál a METTOL dátummal számoljunk).</strong></p>
<ol type="a">
<li>A lista jelenítse meg a részösszegeket és a végösszeget is!</li>
<li>A végösszeget jelöljük megfelelően!</li>
<li>Az oszlopokat nevezzük el értelemszerűen!</li>
</ol>
<p><span class='tg_task'>▷</span>	Listázzuk a szálláshelyek adatait a rögzítési idejének sorrendjében!</p>
<ol type="a">
<li>Egy-egy új oszlopban jelenjen meg az eddig rögzített szálláshelyek minimális és maximális csillagszáma is (az aktuálisat is beleértve) a szálláshely helyén belül!</li>
</ol>

</article>

<a class="github-fork-ribbon" href="https://github.com/sindresorhus/github-markdown-css" data-ribbon="Fork me on GitHub" title="Fork me on GitHub">Fork me on GitHub</a>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script>
<script src="../../assets/article.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.26.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.26.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.26.0/plugins/line-numbers/prism-line-numbers.js"></script>

<!-- Video wrap -->
<div id="inlineVideo_template" class="jump nodisplay">
    <video id="centvideo" playsinline controls></video>
    <div></div>
</div>
</body>
</html>
